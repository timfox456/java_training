## Lab 5: Enhancing the Product REST API (DTOs, Global Exception Handling, Pagination)

**Goal:** Improve the existing `product-api` by introducing industry best practices for REST API design: using Data Transfer Objects (DTOs) for input/output, implementing a global exception handler for consistent error responses, and adding pagination/sorting to the product listing.

**Concepts You'll Learn:**

- **Data Transfer Objects (DTOs):** Why and how to use them to decouple your domain model from your API contract.
    
- **Global Exception Handling:** Using `@ControllerAdvice` and `@ExceptionHandler` for centralized error management.
    
- **Pagination & Sorting:** How to accept pagination/sorting parameters for listing resources.
    

**Prerequisites:**

- Completed Lab 4 successfully.
    
- Your `product-api` project from Lab 4.
    
- **Optional (but recommended):** Restart your Spring Boot application _before_ starting this lab, so the H2 database is reset to its initial three products.
    

---

### Part 1: Introduce Data Transfer Objects (DTOs)

Currently, your API directly exposes and accepts the `Product` JPA entity. While simple for basic cases, this is not ideal. DTOs allow you to control exactly what data is sent over the wire, protect your internal model, and cater to different API use cases.


For this to work, you need to update your pom.xml to add a new dependency:

```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-validation</artifactId>
   </dependency>

```
We'll create two DTOs: `ProductRequest` (for creating/updating) and `ProductResponse` (for returning product data).

1. **Create a new package:**
    
    - In `src/main/java/com/example/productapi`, create a new folder named `dto`. This will correspond to a new package `com.example.productapi.dto`.
        
2. **Create `ProductRequest.java`:**
    
    - In the `src/main/java/com/example/productapi/dto` directory, create a new file named `ProductRequest.java`.
        
    - Add the following code. Note that it includes the validation annotations from Lab 3, but _doesn't_ include the `id` as it's generated by the backend.
        
    

    ```java
    package com.example.productapi.dto;
    
    import jakarta.validation.constraints.DecimalMin;
    import jakarta.validation.constraints.NotBlank;
    import jakarta.validation.constraints.Size;
    
    public class ProductRequest {
    
        @NotBlank(message = "Product name is required")
        @Size(min = 2, max = 100, message = "Product name must be between 2 and 100 characters")
        private String name;
    
        @Size(max = 500, message = "Description cannot exceed 500 characters")
        private String description;
    
        @DecimalMin(value = "0.01", message = "Price must be greater than 0")
        private double price;
    
        // Constructors
        public ProductRequest() {
        }
    
        public ProductRequest(String name, String description, double price) {
            this.name = name;
            this.description = description;
            this.price = price;
        }
    
        // Getters and Setters
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getDescription() {
            return description;
        }
    
        public void setDescription(String description) {
            this.description = description;
        }
    
        public double getPrice() {
            return price;
        }
    
        public void setPrice(double price) {
            this.price = price;
        }
    
        @Override
        public String toString() {
            return "ProductRequest{" +
                   "name='" + name + '\'' +
                   ", description='" + description + '\'' +
                   ", price=" + price +
                   '}';
        }
    }
    ```
    
    _Self-correction tip:_ Ensure `jakarta.validation.constraints` imports are correct.
    
3. **Create `ProductResponse.java`:**
    
    - In the `src/main/java/com/example/productapi/dto` directory, create a new file named `ProductResponse.java`.
        
    - This DTO will contain exactly what you want to send back to the client.
        
    
    
    ```java
    package com.example.productapi.dto;
    
    public class ProductResponse {
        private Long id;
        private String name;
        private String description;
        private double price;
    
        // Constructors
        public ProductResponse() {
        }
    
        public ProductResponse(Long id, String name, String description, double price) {
            this.id = id;
            this.name = name;
            this.description = description;
            this.price = price;
        }
    
        // Getters and Setters
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getDescription() {
            return description;
        }
    
        public void setDescription(String description) {
            this.description = description;
        }
    
        public double getPrice() {
            return price;
        }
    
        public void setPrice(double price) {
            this.price = price;
        }
    
        @Override
        public String toString() {
            return "ProductResponse{" +
                   "id=" + id +
                   ", name='" + name + '\'' +
                   ", description='" + description + '\'' +
                   ", price=" + price +
                   '}';
        }
    }
    ```
    
    _Self-correction tip:_ No special imports needed here.
    
4. **Update `ProductController.java` to use DTOs:**
    
    - Modify the controller methods to accept `ProductRequest` for POST/PUT and return `ProductResponse` for all. You'll need to convert between `Product` entity and DTOs.
        
    
    
    ```java
    package com.example.productapi;
    
    import com.example.productapi.dto.ProductRequest; // NEW
    import com.example.productapi.dto.ProductResponse; // NEW
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;
    import jakarta.validation.Valid;
    
    import java.util.List;
    import java.util.stream.Collectors; // NEW for stream operations
    
    @RestController
    @RequestMapping("/api/products")
    public class ProductController {
    
        private final ProductService productService;
    
        @Autowired
        public ProductController(ProductService productService) {
            this.productService = productService;
        }
    
        // Helper method to convert Product entity to ProductResponse DTO
        private ProductResponse convertToResponseDto(Product product) {
            if (product == null) {
                return null;
            }
            return new ProductResponse(product.getId(), product.getName(), product.getDescription(), product.getPrice());
        }
    
        // Helper method to convert ProductRequest DTO to Product entity
        private Product convertToEntity(ProductRequest productRequest) {
            if (productRequest == null) {
                return null;
            }
            // ID will be null for new products, generated by DB
            return new Product(null, productRequest.getName(), productRequest.getDescription(), productRequest.getPrice());
        }
    
        // GET all products - NOW RETURNS List<ProductResponse>
        @GetMapping
        public List<ProductResponse> getAllProducts() {
            return productService.getAllProducts().stream()
                                 .map(this::convertToResponseDto)
                                 .collect(Collectors.toList());
        }
    
        // GET a product by ID - NOW RETURNS ProductResponse
        @GetMapping("/{id}")
        public ResponseEntity<ProductResponse> getProductById(@PathVariable Long id) {
            return productService.getProductById(id)
                    .map(this::convertToResponseDto) // Convert entity to DTO
                    .map(productResponse -> new ResponseEntity<>(productResponse, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
        }
    
        // POST (Create) a new product - NOW ACCEPTS ProductRequest and RETURNS ProductResponse
        @PostMapping
        public ResponseEntity<ProductResponse> addProduct(@Valid @RequestBody ProductRequest productRequest) {
            Product productToSave = convertToEntity(productRequest); // Convert DTO to entity
            Product newProduct = productService.addProduct(productToSave);
            return new ResponseEntity<>(convertToResponseDto(newProduct), HttpStatus.CREATED); // Convert saved entity to DTO
        }
    
        // PUT (Update) an existing product - NOW ACCEPTS ProductRequest and RETURNS ProductResponse
        @PutMapping("/{id}")
        public ResponseEntity<ProductResponse> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductRequest productRequest) {
            Product updatedEntityDetails = convertToEntity(productRequest); // Convert DTO to entity
            return productService.updateProduct(id, updatedEntityDetails)
                    .map(this::convertToResponseDto) // Convert updated entity to DTO
                    .map(updatedProductResponse -> new ResponseEntity<>(updatedProductResponse, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
        }
    
        // DELETE a product (no change in signature, but now ProductService operates on entity)
        @DeleteMapping("/{id}")
        public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
            if (productService.deleteProduct(id)) {
                return new ResponseEntity<>(HttpStatus.NO_CONTENT);
            } else {
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }
        }
    }
    ```
    
    _Self-correction tip:_ Add `import com.example.productapi.dto.ProductRequest;` and `import com.example.productapi.dto.ProductResponse;`. Also, `import java.util.stream.Collectors;` for the `stream().map().collect()` operations.
    
5. **Update `Product.java` (Minor Change):**
    
    - The `ProductService` methods still operate on the `Product` entity, which is correct. No signature changes are needed here, as the conversion happens in the controller.
        
    - **However, remove the validation annotations from the `Product` entity if they are still there!** Validation should primarily happen on the DTOs when they come in from the request. The entity itself shouldn't have direct validation annotations if the DTO is handling it.
        
    
    ```java
    package com.example.productapi;
    
    import jakarta.persistence.Entity;
    import jakarta.persistence.GeneratedValue;
    import jakarta.persistence.GenerationType;
    import jakarta.persistence.Id;
    // REMOVE these imports from Product.java:
    // import jakarta.validation.constraints.NotBlank;
    // import jakarta.validation.constraints.DecimalMin;
    // import jakarta.validation.constraints.Size;
    
    @Entity
    public class Product {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        // REMOVE validation annotations from entity fields:
        // @NotBlank(message = "Product name is required")
        // @Size(min = 2, max = 100, message = "Product name must be between 2 and 100 characters")
        private String name;
    
        // @Size(max = 500, message = "Description cannot exceed 500 characters")
        private String description;
    
        // @DecimalMin(value = "0.01", message = "Price must be greater than 0")
        private double price;
    
        // ... (rest of your constructors, getters, setters, toString remain the same)
    }
    ```
    
    _Self-correction tip:_ Make sure you remove the `@NotBlank`, `@Size`, and `@DecimalMin` annotations from the `Product`entity and their corresponding imports.

    Here's what it should look like at the end:


    

---

### Part 2: Global Exception Handling

Instead of letting Spring Boot return a generic error page for exceptions like "Product Not Found", we can create a centralized handler for more consistent and API-friendly error responses.

1. **Create a Custom Exception:** First, let's create a specific exception for when a product is not found.
    
    - In the `src/main/java/com/example/productapi` directory, create a new file named `ProductNotFoundException.java`.
        
    
    Java
    
    ```
    package com.example.productapi;
    
    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;
    
    @ResponseStatus(HttpStatus.NOT_FOUND) // This annotation tells Spring to return 404 when this exception is thrown
    public class ProductNotFoundException extends RuntimeException {
    
        public ProductNotFoundException(Long id) {
            super("Could not find product " + id);
        }
    }
    ```
    
    _Self-correction tip:_ Ensure `HttpStatus` and `ResponseStatus` are imported.
    
2. **Modify `ProductService` to throw `ProductNotFoundException`:**
    
    - Open `ProductService.java` and modify `getProductById` and `updateProduct` to throw this new exception if the product isn't found, rather than returning `Optional.empty()`. The controller will then catch it.
        
    
    
    ```java
    package com.example.productapi;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import java.util.List;
    import java.util.Optional;
    
    @Service
    public class ProductService {
    
        private final ProductRepository productRepository;
    
        @Autowired
        public ProductService(ProductRepository productRepository) {
            this.productRepository = productRepository;
        }
    
        public List<Product> getAllProducts() {
            return productRepository.findAll();
        }
    
        // MODIFIED: Throws ProductNotFoundException if not found
        public Product getProductById(Long id) {
            return productRepository.findById(id)
                                    .orElseThrow(() -> new ProductNotFoundException(id));
        }
    
        // MODIFIED: Throws ProductNotFoundException if not found
        public Product updateProduct(Long id, Product updatedProduct) {
            return productRepository.findById(id)
                           .map(product -> {
                               product.setName(updatedProduct.getName());
                               product.setDescription(updatedProduct.getDescription());
                               product.setPrice(updatedProduct.getPrice());
                               return productRepository.save(product);
                           })
                           .orElseThrow(() -> new ProductNotFoundException(id)); // Throw if not found
        }
    
        public boolean deleteProduct(Long id) {
            if (productRepository.existsById(id)) {
                productRepository.deleteById(id);
                return true;
            }
            return false; // Still return false if not found for simpler controller logic
        }
    }
    ```
    
    _Self-correction tip:_ Add `import java.util.Optional;` if it's no longer automatically imported. Remove any existing `map().orElse()` structures in `getProductById` and `updateProduct` if they are different from above.
    
3. **Create Global Exception Handler (`RestExceptionHandler.java`):**
    
    - In the `src/main/java/com/example/productapi` directory, create a new file named `RestExceptionHandler.java`.
        

    
    ```java
    package com.example.productapi;
    
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.MethodArgumentNotValidException;
    import org.springframework.web.bind.annotation.ControllerAdvice;
    import org.springframework.web.bind.annotation.ExceptionHandler;
    import org.springframework.web.context.request.WebRequest;
    
    import java.time.LocalDateTime;
    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.stream.Collectors;
    
    @ControllerAdvice // Marks this class to provide centralized exception handling across all @Controller classes
    public class RestExceptionHandler {
    
        // Handles ProductNotFoundException, returning a 404 NOT FOUND
        @ExceptionHandler(ProductNotFoundException.class)
        public ResponseEntity<Object> handleProductNotFoundException(ProductNotFoundException ex, WebRequest request) {
            Map<String, Object> body = new LinkedHashMap<>();
            body.put("timestamp", LocalDateTime.now());
            body.put("status", HttpStatus.NOT_FOUND.value());
            body.put("error", "Not Found");
            body.put("message", ex.getMessage());
            body.put("path", request.getDescription(false).replace("uri=", "")); // Extract path
    
            return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
        }
    
        // Handles validation exceptions (e.g., @NotBlank, @Size), returning a 400 BAD REQUEST
        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, WebRequest request) {
            Map<String, Object> body = new LinkedHashMap<>();
            body.put("timestamp", LocalDateTime.now());
            body.put("status", HttpStatus.BAD_REQUEST.value());
            body.put("error", "Bad Request");
    
            // Get all validation errors and format them
            List<String> errors = ex.getBindingResult()
                                    .getFieldErrors()
                                    .stream()
                                    .map(x -> x.getField() + ": " + x.getDefaultMessage())
                                    .collect(Collectors.toList());
    
            body.put("messages", errors);
            body.put("path", request.getDescription(false).replace("uri=", ""));
    
            return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
        }
    
        // Add other @ExceptionHandler methods here for other custom or common exceptions
        // For example, a general catch-all for any RuntimeException
        @ExceptionHandler(Exception.class)
        public ResponseEntity<Object> handleGenericException(Exception ex, WebRequest request) {
            Map<String, Object> body = new LinkedHashMap<>();
            body.put("timestamp", LocalDateTime.now());
            body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
            body.put("error", "Internal Server Error");
            body.put("message", "An unexpected error occurred: " + ex.getMessage());
            body.put("path", request.getDescription(false).replace("uri=", ""));
    
            return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    ```
    
    _Self-correction tip:_ Ensure all imports are correct (`HttpStatus`, `ResponseEntity`, `MethodArgumentNotValidException`, `ControllerAdvice`, `ExceptionHandler`, `WebRequest`, `LinkedHashMap`, `Map`, `LocalDateTime`, `Collectors`).
    
4. **Update `ProductController.java` (Minor Change):**
    
    - The `getProductById` and `updateProduct` methods no longer need `.orElse()` or `.orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND))`. They will simply call `productService.getProductById(id)` which now throws an exception if not found, and the `RestExceptionHandler` will catch it.
        

    ```java
    package com.example.productapi;
    
    import com.example.productapi.dto.ProductRequest;
    import com.example.productapi.dto.ProductResponse;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;
    import jakarta.validation.Valid;
    
    import java.util.List;
    import java.util.stream.Collectors;
    
    @RestController
    @RequestMapping("/api/products")
    public class ProductController {
    
        private final ProductService productService;
    
        @Autowired
        public ProductController(ProductService productService) {
            this.productService = productService;
        }
    
        private ProductResponse convertToResponseDto(Product product) {
            if (product == null) {
                return null;
            }
            return new ProductResponse(product.getId(), product.getName(), product.getDescription(), product.getPrice());
        }
    
        private Product convertToEntity(ProductRequest productRequest) {
            if (productRequest == null) {
                return null;
            }
            return new Product(null, productRequest.getName(), productRequest.getDescription(), productRequest.getPrice());
        }
    
        // GET all products (no change)
        @GetMapping
        public List<ProductResponse> getAllProducts() {
            return productService.getAllProducts().stream()
                                 .map(this::convertToResponseDto)
                                 .collect(Collectors.toList());
        }
    
        // MODIFIED: Simplified due to exception handling in service
        @GetMapping("/{id}")
        public ResponseEntity<ProductResponse> getProductById(@PathVariable Long id) {
            Product product = productService.getProductById(id); // This now throws ProductNotFoundException
            return new ResponseEntity<>(convertToResponseDto(product), HttpStatus.OK);
        }
    
        // POST (Create) a new product (no change in signature, logic slightly modified to use DTOs)
        @PostMapping
        public ResponseEntity<ProductResponse> addProduct(@Valid @RequestBody ProductRequest productRequest) {
            Product productToSave = convertToEntity(productRequest);
            Product newProduct = productService.addProduct(productToSave);
            return new ResponseEntity<>(convertToResponseDto(newProduct), HttpStatus.CREATED);
        }
    
        // MODIFIED: Simplified due to exception handling in service
        @PutMapping("/{id}")
        public ResponseEntity<ProductResponse> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductRequest productRequest) {
            Product updatedEntityDetails = convertToEntity(productRequest);
            Product updatedProduct = productService.updateProduct(id, updatedEntityDetails); // This now throws ProductNotFoundException
            return new ResponseEntity<>(convertToResponseDto(updatedProduct), HttpStatus.OK);
        }
    
        // DELETE a product (no change)
        @DeleteMapping("/{id}")
        public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
            if (productService.deleteProduct(id)) {
                return new ResponseEntity<>(HttpStatus.NO_CONTENT);
            } else {
                return new ResponseEntity<>(HttpStatus.NOT_FOUND); // Still handles if deleteProduct returns false
            }
        }
    }
    ```
    
    _Self-correction tip:_ Remove the `Optional` handling from `getProductById` and `updateProduct` in the controller.
    

---

### Part 3: Implement Pagination and Sorting

Now, let's allow clients to request products with pagination (how many per page, which page) and sorting (by which field, ascending/descending).

1. **Modify `ProductService.java` to accept `Pageable`:**
    
    - Spring Data JPA's `JpaRepository` already has methods that accept `Pageable`. We just need to expose them in our service.
        

    ```java
    package com.example.productapi;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.data.domain.Page; // NEW
    import org.springframework.data.domain.Pageable; // NEW
    
    import java.util.List;
    
    @Service
    public class ProductService {
    
        private final ProductRepository productRepository;
    
        @Autowired
        public ProductService(ProductRepository productRepository) {
            this.productRepository = productRepository;
        }
    
        // MODIFIED: New method for paginated and sorted results
        public Page<Product> getAllProducts(Pageable pageable) {
            return productRepository.findAll(pageable); // Use JpaRepository's findAll(Pageable)
        }
    
        // Keep the existing getAllProducts() if you still want an unsorted/unpaginated option
        public List<Product> getAllProducts() {
            return productRepository.findAll();
        }
    
        // ... (rest of your getProductById, addProduct, updateProduct, deleteProduct methods remain the same)
        public Product getProductById(Long id) {
            return productRepository.findById(id)
                                    .orElseThrow(() -> new ProductNotFoundException(id));
        }
    
        public Product addProduct(Product product) {
            return productRepository.save(product);
        }
    
        public Product updateProduct(Long id, Product updatedProduct) {
            return productRepository.findById(id)
                           .map(product -> {
                               product.setName(updatedProduct.getName());
                               product.setDescription(updatedProduct.getDescription());
                               product.setPrice(updatedProduct.getPrice());
                               return productRepository.save(product);
                           })
                           .orElseThrow(() -> new ProductNotFoundException(id));
        }
    
        public boolean deleteProduct(Long id) {
            if (productRepository.existsById(id)) {
                productRepository.deleteById(id);
                return true;
            }
            return false;
        }
    }
    ```
    
    _Self-correction tip:_ Add `import org.springframework.data.domain.Page;` and `import org.springframework.data.domain.Pageable;`.
    
2. **Modify `ProductController.java` to accept pagination/sorting parameters:**
    
    - Spring provides `@PageableDefault` and `Pageable` as a method argument that automatically binds request parameters.
        

    ```java
    package com.example.productapi;
    
    import com.example.productapi.dto.ProductRequest;
    import com.example.productapi.dto.ProductResponse;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;
    import jakarta.validation.Valid;
    
    import org.springframework.data.domain.Page; // NEW
    import org.springframework.data.domain.Pageable; // NEW
    import org.springframework.data.web.PageableDefault; // NEW
    import java.util.List;
    import java.util.stream.Collectors;
    
    @RestController
    @RequestMapping("/api/products")
    public class ProductController {
    
        private final ProductService productService;
    
        @Autowired
        public ProductController(ProductService productService) {
            this.productService = productService;
        }
    
        private ProductResponse convertToResponseDto(Product product) {
            if (product == null) {
                return null;
            }
            return new ProductResponse(product.getId(), product.getName(), product.getDescription(), product.getPrice());
        }
    
        private Product convertToEntity(ProductRequest productRequest) {
            if (productRequest == null) {
                return null;
            }
            return new Product(null, productRequest.getName(), productRequest.getDescription(), productRequest.getPrice());
        }
    
        // MODIFIED: Now supports pagination and sorting for GET /api/products
        // Example: /api/products?page=0&size=2&sort=name,asc
        // @PageableDefault provides default values if parameters are not provided
        @GetMapping
        public Page<ProductResponse> getAllProducts(@PageableDefault(size = 5, sort = "name") Pageable pageable) {
            return productService.getAllProducts(pageable)
                                 .map(this::convertToResponseDto); // Convert Page<Product> to Page<ProductResponse>
        }
    
        // You might consider removing the non-paginated getAllProducts method if
        // pagination is always desired, or rename it (e.g., /api/products/all)
        // For this lab, we'll replace the existing one.
        // public List<ProductResponse> getAllProducts() {
        //     return productService.getAllProducts().stream()
        //                          .map(this::convertToResponseDto)
        //                          .collect(Collectors.toList());
        // }
    
    
        // ... (rest of your getProductById, addProduct, updateProduct, deleteProduct methods remain the same)
        @GetMapping("/{id}")
        public ResponseEntity<ProductResponse> getProductById(@PathVariable Long id) {
            Product product = productService.getProductById(id);
            return new ResponseEntity<>(convertToResponseDto(product), HttpStatus.OK);
        }
    
        @PostMapping
        public ResponseEntity<ProductResponse> addProduct(@Valid @RequestBody ProductRequest productRequest) {
            Product productToSave = convertToEntity(productRequest);
            Product newProduct = productService.addProduct(productToSave);
            return new ResponseEntity<>(convertToResponseDto(newProduct), HttpStatus.CREATED);
        }
    
        @PutMapping("/{id}")
        public ResponseEntity<ProductResponse> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductRequest productRequest) {
            Product updatedEntityDetails = convertToEntity(productRequest);
            Product updatedProduct = productService.updateProduct(id, updatedEntityDetails);
            return new ResponseEntity<>(convertToResponseDto(updatedProduct), HttpStatus.OK);
        }
    
        @DeleteMapping("/{id}")
        public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
            if (productService.deleteProduct(id)) {
                return new ResponseEntity<>(HttpStatus.NO_CONTENT);
            } else {
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }
        }
    }
    ```
    
    _Self-correction tip:_ Add `import org.springframework.data.domain.Page;`, `import org.springframework.data.domain.Pageable;`, and `import org.springframework.data.web.PageableDefault;`. If you kept the non-paginated `getAllProducts()` method in `ProductService`, you'll need to decide if you want to keep both `getAllProducts()` methods in the controller or just replace it with the paginated one. For simplicity in this lab, replacing the old one is fine.
    

---

### Part 4: Testing Your Enhanced API

Start your Spring Boot application (ensure H2 is reset by restarting the app if you added products in previous labs).

1. **Start Your Spring Boot Application:**
    
    - Go to your `ProductApiApplication.java` file.
        
    - Click the **"Run"** button.
        
    - Ensure the application starts successfully on port 8080.
        
    - **Important:** If you added `DataLoader.java` in Lab 2, your database will always start with 3 products. This is good for testing pagination.
        

#### Testing with Thunder Client (VS Code)

Use Thunder Client (the lightning bolt icon in the Activity Bar) to send requests. Remember to provide Basic Auth credentials (e.g., `user:password` or `admin:adminpass`) for all `/api/products` requests.

1. **Create New Request:** Click "New Request".
    
    **a) Test 1: GET All Products (Basic Pagination - Default Size/Sort)**
    
    - **Method:** `GET`
        
    - **URL:** `http://localhost:8080/api/products`
        
    - **Auth:** `Basic Auth` (`user:password`)
        
    - **Send:** Click "Send".
        
    - **Expected Response:** `200 OK`. The JSON response will now be a `Page` object with content, page info (number, size, total elements, total pages), and sort info. By default, it will sort by `name` ascending and show `5`items (your `PageableDefault` config).
        
        ```json
        {
            "content": [
                { "id": 3, "name": "Keyboard", ... },
                { "id": 1, "name": "Laptop", ... },
                { "id": 2, "name": "Mouse", ... }
            ],
            "pageable": { ... },
            "last": true,
            "totalElements": 3,
            "totalPages": 1,
            "size": 5,
            "number": 0,
            "sort": { "empty": false, "sorted": true, "unsorted": false },
            "first": true,
            "numberOfElements": 3,
            "empty": false
        }
        ```
        
    
    **b) Test 2: GET All Products (Pagination with `size` and `page`)**
    
    - **Method:** `GET`
        
    - **URL:** `http://localhost:8080/api/products?page=0&size=2`
        
    - **Auth:** `Basic Auth` (`user:password`)
        
    - **Send:** Click "Send".
        
    - **Expected Response:** `200 OK`. You should see `content` with only 2 products, `size: 2`, `number: 0`, and `totalPages: 2`.
        
    
    **c) Test 3: GET All Products (Pagination with `sort`)**
    
    - **Method:** `GET`
        
    - **URL:** `http://localhost:8080/api/products?sort=price,desc`
        
    - **Auth:** `Basic Auth` (`user:password`)
        
    - **Send:** Click "Send".
        
    - **Expected Response:** `200 OK`. Products should be sorted by price in descending order.
        
    
    **d) Test 4: GET Product by ID (Not Found - Global Exception Handling)**
    
    - **Method:** `GET`
        
    - **URL:** `http://localhost:8080/api/products/999` (an ID that definitely doesn't exist)
        
    - **Auth:** `Basic Auth` (`user:password`)
        
    - **Send:** Click "Send".
        
    - **Expected Response:** `404 Not Found`. The response body should now be the custom JSON format you defined in `RestExceptionHandler`:
        
        JSON
        
        ```
        {
            "timestamp": "2025-06-25T15:30:00.123456789",
            "status": 404,
            "error": "Not Found",
            "message": "Could not find product 999",
            "path": "/api/products/999"
        }
        ```
        
    
    **e) Test 5: POST Invalid Product (Validation Errors - Global Exception Handling)**
    
    - **Method:** `POST`
        
    - **URL:** `http://localhost:8080/api/products`
        
    - **Auth:** `Basic Auth` (`admin:adminpass`)
        
    - **Headers:** `Content-Type: application/json`
        
    - **Body:** Select `JSON` and paste (invalid data: empty name, price 0):
        
        JSON
        
        ```
        {
            "name": "",
            "description": "Invalid product data test.",
            "price": 0.0
        }
        ```
        
    - **Send:** Click "Send".
        
    - **Expected Response:** `400 Bad Request`. The response body should contain your custom validation error format from `RestExceptionHandler`:
        
        JSON
        
        ```
        {
            "timestamp": "2025-06-25T15:30:00.123456789",
            "status": 400,
            "error": "Bad Request",
            "messages": [
                "name: Product name is required",
                "price: Price must be greater than 0"
            ],
            "path": "/api/products"
        }
        ```
        

#### `curl` Appendix for Lab 5 Testing

Remember to provide Basic Auth (`-u username:password`) for all `/api/products` commands. Replace placeholder IDs or add new products to test updates and deletions effectively.

Bash

```
# Ensure your Spring Boot application is running before executing these.

echo "--- Lab 5: Enhanced REST API Tests with curl ---"

# Note: For security, we're using 'user:password' or 'admin:adminpass' for authentication.

# 1. GET All Products (Basic Pagination - Default Size/Sort)
#    Expected: HTTP 200 OK, paginated JSON response with default sorting by name.
echo "--- GET /api/products (Default Paginated) ---"
curl -v -X GET -u user:password http://localhost:8080/api/products
echo ""
echo "----------------------------------------"

# 2. GET All Products (Pagination with 'page' and 'size')
#    Expected: HTTP 200 OK, content will show products on page 0 with 2 items.
echo "--- GET /api/products?page=0&size=2 ---"
curl -v -X GET -u user:password "http://localhost:8080/api/products?page=0&size=2"
echo ""
echo "----------------------------------------"

# 3. GET All Products (Pagination with 'sort' by price descending)
#    Expected: HTTP 200 OK, content sorted by price descending.
echo "--- GET /api/products?sort=price,desc ---"
curl -v -X GET -u user:password "http://localhost:8080/api/products?sort=price,desc"
echo ""
echo "----------------------------------------"

# 4. GET Product by ID (Not Found - Global Exception Handling)
#    Expected: HTTP 404 Not Found, custom JSON error response.
echo "--- GET /api/products/999 (Not Found) ---"
curl -v -X GET -u user:password http://localhost:8080/api/products/999
echo ""
echo "----------------------------------------"

# 5. POST Invalid Product (Validation Errors - Global Exception Handling)
#    Empty name, price <= 0.
#    Expected: HTTP 400 Bad Request, custom JSON validation error response.
echo "--- POST /api/products (Invalid Data) ---"
curl -v -X POST \
     -H "Content-Type: application/json" \
     -u admin:adminpass \
     -d '{ "name": "", "description": "Invalid product data test.", "price": 0.0 }' \
     http://localhost:8080/api/products
echo ""
echo "----------------------------------------"

# 6. POST Valid Product (to verify POST still works with DTOs and validation)
#    Expected: HTTP 201 Created, JSON of new product.
echo "--- POST /api/products (Valid Data) ---"
curl -v -X POST \
     -H "Content-Type: application/json" \
     -u admin:adminpass \
     -d '{ "name": "Tablet", "description": "Compact tablet for reading.", "price": 300.00 }' \
     http://localhost:8080/api/products
echo ""
echo "----------------------------------------"
```

---

### Congratulations!

You've significantly enhanced your Spring Boot REST API! You now have a more robust, maintainable, and client-friendly API that leverages DTOs, provides consistent error responses, and supports efficient data retrieval through pagination and sorting. This is a huge step towards real-world application development.
